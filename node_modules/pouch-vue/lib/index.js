(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('buffer'), require('events'), require('util'), require('crypto')) :
  typeof define === 'function' && define.amd ? define(['buffer', 'events', 'util', 'crypto'], factory) :
  (global = global || self, factory(global.buffer, global.events, global.util, global.crypto));
}(this, function (buffer, events, util, crypto) { 'use strict';

  buffer = buffer && buffer.hasOwnProperty('default') ? buffer['default'] : buffer;
  util = util && util.hasOwnProperty('default') ? util['default'] : util;
  crypto = crypto && crypto.hasOwnProperty('default') ? crypto['default'] : crypto;

  var Buffer = buffer.Buffer;

  function mangle(key) {
    return '$' + key;
  }
  function unmangle(key) {
    return key.substring(1);
  }
  function Map$1() {
    this._store = {};
  }
  Map$1.prototype.get = function (key) {
    var mangled = mangle(key);
    return this._store[mangled];
  };
  Map$1.prototype.set = function (key, value) {
    var mangled = mangle(key);
    this._store[mangled] = value;
    return true;
  };
  Map$1.prototype.has = function (key) {
    var mangled = mangle(key);
    return mangled in this._store;
  };
  Map$1.prototype.delete = function (key) {
    var mangled = mangle(key);
    var res = mangled in this._store;
    delete this._store[mangled];
    return res;
  };
  Map$1.prototype.forEach = function (cb) {
    var keys = Object.keys(this._store);
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      var value = this._store[key];
      key = unmangle(key);
      cb(value, key);
    }
  };
  Object.defineProperty(Map$1.prototype, 'size', {
    get: function () {
      return Object.keys(this._store).length;
    }
  });

  function Set$1(array) {
    this._store = new Map$1();

    // init with an array
    if (array && Array.isArray(array)) {
      for (var i = 0, len = array.length; i < len; i++) {
        this.add(array[i]);
      }
    }
  }
  Set$1.prototype.add = function (key) {
    return this._store.set(key, true);
  };
  Set$1.prototype.has = function (key) {
    return this._store.has(key);
  };
  Set$1.prototype.forEach = function (cb) {
    this._store.forEach(function (value, key) {
      cb(key);
    });
  };
  Object.defineProperty(Set$1.prototype, 'size', {
    get: function () {
      return this._store.size;
    }
  });

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  });

  var inherits = createCommonjsModule(function (module) {
  try {
    var util$1 = util;
    if (typeof util$1.inherits !== 'function') { throw ''; }
    module.exports = util$1.inherits;
  } catch (e) {
    module.exports = inherits_browser;
  }
  });

  inherits(PouchError, Error);

  function PouchError(status, error, reason) {
    Error.call(this, reason);
    this.status = status;
    this.name = error;
    this.message = reason;
    this.error = true;
  }

  PouchError.prototype.toString = function () {
    return JSON.stringify({
      status: this.status,
      name: this.name,
      message: this.message,
      reason: this.reason
    });
  };

  var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
  var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
  var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
  var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
  var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
  var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
  var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
  var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
  var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
  var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
  var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
  var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
  var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
  var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
  var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
  var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
  var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
  var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
  var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
  var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
  var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
  var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
  var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
  var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  // most of this is borrowed from lodash.isPlainObject:
  // https://github.com/fis-components/lodash.isplainobject/
  // blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

  var funcToString = Function.prototype.toString;
  var objectCtorString = funcToString.call(Object);

  // like underscore/lodash _.pick()
  function pick(obj, arr) {
    var res = {};
    for (var i = 0, len = arr.length; i < len; i++) {
      var prop = arr[i];
      if (prop in obj) {
        res[prop] = obj[prop];
      }
    }
    return res;
  }

  function nextTick(fn) {
    process.nextTick(fn);
  }

  inherits(Changes, events.EventEmitter);

  function Changes() {
    events.EventEmitter.call(this);
    this._listeners = {};
  }
  Changes.prototype.addListener = function (dbName, id, db, opts) {
    /* istanbul ignore if */
    if (this._listeners[id]) {
      return;
    }
    var self = this;
    var inprogress = false;
    function eventFunction() {
      /* istanbul ignore if */
      if (!self._listeners[id]) {
        return;
      }
      if (inprogress) {
        inprogress = 'waiting';
        return;
      }
      inprogress = true;
      var changesOpts = pick(opts, [
        'style', 'include_docs', 'attachments', 'conflicts', 'filter',
        'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'
      ]);

      /* istanbul ignore next */
      function onError() {
        inprogress = false;
      }

      db.changes(changesOpts).on('change', function (c) {
        if (c.seq > opts.since && !opts.cancelled) {
          opts.since = c.seq;
          opts.onChange(c);
        }
      }).on('complete', function () {
        if (inprogress === 'waiting') {
          nextTick(eventFunction);
        }
        inprogress = false;
      }).on('error', onError);
    }
    this._listeners[id] = eventFunction;
    this.on(dbName, eventFunction);
  };

  Changes.prototype.removeListener = function (dbName, id) {
    /* istanbul ignore if */
    if (!(id in this._listeners)) {
      return;
    }
    events.EventEmitter.prototype.removeListener.call(this, dbName,
      this._listeners[id]);
    delete this._listeners[id];
  };


  /* istanbul ignore next */
  Changes.prototype.notifyLocalWindows = function (dbName) {
  };

  Changes.prototype.notify = function (dbName) {
    this.emit(dbName);
    this.notifyLocalWindows(dbName);
  };

  function guardedConsole(method) {
    /* istanbul ignore else */
    if (typeof console !== 'undefined' && typeof console[method] === 'function') {
      var args = Array.prototype.slice.call(arguments, 1);
      console[method].apply(console, args);
    }
  }

  // Checks if a PouchDB object is "remote" or not. This is

  function isRemote(db) {
    if (typeof db._remote === 'boolean') {
      return db._remote;
    }
    /* istanbul ignore next */
    if (typeof db.type === 'function') {
      guardedConsole('warn',
        'db.type() is deprecated and will be removed in ' +
        'a future version of PouchDB');
      return db.type() === 'http';
    }
    /* istanbul ignore next */
    return false;
  }

  (function() {
      var vue = null,
          pouch = null,
          defaultDB = null,
          defaultUsername = null,
          defaultPassword = null,
          databases = {},
          optionsDB = {};

      var vuePouch = {
          /* Creates a property in 'data' with 'null' value for each pouch property
           * defined on the component.  This way the user does not have to manually
           * define a data property for the reactive databases/selectors.
           *
           * This partial 'data' object is mixed into the components along with
           * the rest of the API (but is empty unless the component has a 'pouch'
           * option).
           */
          data: function data(vm) {
              var pouchOptions = vm.$options.pouch;
              if (typeof pouchOptions === 'undefined' || pouchOptions === null) { return {}; }
              if (typeof pouchOptions === 'function') { pouchOptions = pouchOptions(vm); }
              return Object.keys(pouchOptions).reduce(function (accumulator, currentValue) {
                  accumulator[currentValue] = null;
                  return accumulator
              }, {});
          },

          // lifecycle hooks for mixin

          // now that the data object has been observed and made reactive
          // the api can be set up
          created: function created() {
              if (!vue) {
                  console.warn('pouch-vue not installed!');
                  return;
              }

              var vm = this;

              vm._liveFeeds = {};

              if (defaultDB) {
                  makeInstance(defaultDB);
              }

              function fetchSession(db) {
                  if ( db === void 0 ) db = databases[defaultDB];

                  return new Promise(function (resolve) {
                      db
                          .getSession()
                          .then(function (session) {
                              db
                                  .getUser(session.userCtx.name)
                                  .then(function (userData) {
                                      var userObj = Object.assign(
                                          {},
                                          session.userCtx,
                                          userData
                                      );
                                      resolve({
                                          user: userObj,
                                          hasAccess: true,
                                      });
                                  })
                                  .catch(function (error) {
                                      resolve(error);
                                  });
                          })
                          .catch(function (error) {
                              resolve(error);
                          });
                  });
              }

              function login(db) {
                  if ( db === void 0 ) db = databases[defaultDB];

                  return new Promise(function (resolve) {

                      db
                          .logIn(defaultUsername, defaultPassword)
                          .then(function (user) {
                              db
                                  .getUser(user.name)
                                  .then(function (userData) {
                                      var userObj = Object.assign(
                                          {},
                                          user,
                                          userData
                                      );
                                      resolve({
                                          user: userObj,
                                          hasAccess: true,
                                      });
                                  })
                                  .catch(function (error) {
                                      resolve(error);
                                  });
                          })
                          .catch(function (error) {
                              resolve(error);
                          });
                  });
              }

              function makeInstance(db, options) {
                  if ( options === void 0 ) options = {};

                  // Merge the plugin optionsDB options with those passed in
                  // when creating pouch dbs.
                  // Note: default opiontsDB options are passed in when creating 
                  // both local and remote pouch databases. E.g. modifying fetch()
                  // in the options is only useful for remote Dbs but will be passed
                  // for local pouch dbs too if set in optionsDB.
                  // See: https://pouchdb.com/api.html#create_database
              
                  var _options = Object.assign(
                      {},
                      optionsDB,
                      options
                  );

                  databases[db] = new pouch(db, _options);
                  registerListeners(databases[db]);
              }

              function registerListeners(db) {
                  db.on('created', function (name) {
                      vm.$emit('pouchdb-db-created', {
                          db: name,
                          ok: true,
                      });
                  });
                  db.on('destroyed', function (name) {
                      vm.$emit('pouchdb-db-destroyed', {
                          db: name,
                          ok: true,
                      });
                  });
              }

              var $pouch = {
                  version: '0.3.5',
                  connect: function connect(username, password, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return new Promise(function (resolve) {
                          defaultUsername = username;
                          defaultPassword = password;

                          if (!isRemote(databases[db])) {
                              resolve({
                                  message: 'database is not remote',
                                  error: 'bad request',
                                  status: 400,
                              });
                              return;
                          }

                          login(databases[db]).then(function (res) {
                              resolve(res);
                          });
                      });
                  },
                  createUser: function createUser(username, password, db) {
                      if ( db === void 0 ) db = defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .signUp(username, password)
                          .then(function () {
                              return vm.$pouch.connect(username, password, db);
                          })
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  putUser: function putUser(username, metadata, db) {
                      if ( metadata === void 0 ) metadata = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .putUser(username, {
                              metadata: metadata,
                          })
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  deleteUser: function deleteUser(username, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .deleteUser(username)
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  changePassword: function changePassword(username, password, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .changePassword(username, password)
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  changeUsername: function changeUsername(oldUsername, newUsername, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .changeUsername(oldUsername, newUsername)
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  signUpAdmin: function signUpAdmin(adminUsername, adminPassword, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .signUpAdmin(adminUsername, adminPassword)
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  deleteAdmin: function deleteAdmin(adminUsername, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db]
                          .deleteAdmin(adminUsername)
                          .catch(function (error) {
                              return new Promise(function (resolve) {
                                  resolve(error);
                              });
                          });
                  },
                  disconnect: function disconnect(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return new Promise(function (resolve) {
                          defaultUsername = null;
                          defaultPassword = null;

                          if (!isRemote(databases[db])) {
                              resolve({
                                  message: 'database is not remote',
                                  error: 'bad request',
                                  status: 400,
                              });
                              return;
                          }

                          databases[db]
                              .logOut()
                              .then(function (res) {
                                  resolve({
                                      ok: res.ok,
                                      user: null,
                                      hasAccess: false,
                                  });
                              })
                              .catch(function (error) {
                                  resolve(error);
                              });
                      });
                  },

                  destroy: function destroy(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].destroy().then(function () {
                          if (db !== defaultDB) {
                              delete databases[db];
                          }
                      });
                  },

                  defaults: function defaults(options) {
                      if ( options === void 0 ) options = {};

                      pouch.defaults(options);
                  },

                  close: function close(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].close().then(function () {
                          if (db !== defaultDB) {
                              delete databases[db];
                          }
                      });
                  },

                  getSession: function getSession(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      if (!isRemote(databases[db])) {
                          return new Promise(function (resolve) {
                              resolve({
                                  message: 'database is not remote',
                                  error: 'bad request',
                                  status: 400,
                              });
                          });
                      }
                      return fetchSession(databases[db]);
                  },

                  sync: function sync(localDB, remoteDB, options) {
                      if ( remoteDB === void 0 ) remoteDB=defaultDB;
                      if ( options === void 0 ) options = {};

                      if (!databases[localDB]) {
                          makeInstance(localDB);
                      }
                      if (!databases[remoteDB]) {
                          makeInstance(remoteDB);
                      }
                      if (!defaultDB) {
                          defaultDB = remoteDB;
                      }

                      var _options = Object.assign(
                          {},
                          {
                              live: true,
                              retry: true,
                              back_off_function: function (delay) {
                                  if (delay === 0) {
                                      return 1000;
                                  }
                                  return delay * 3;
                              },
                          },
                          options
                      );

                      var sync = pouch
                          .sync(databases[localDB], databases[remoteDB], _options)
                          .on('paused', function (err) {
                              if (err) {
                                  vm.$emit('pouchdb-sync-error', {
                                      db: localDB,
                                      error: err,
                                  });
                                  return;
                              }
                              else {

                                  vm.$emit('pouchdb-sync-paused', {
                                      db: localDB,
                                      paused: true,
                                  });
                              }
                          })
                          .on('change', function (info) {
                              vm.$emit('pouchdb-sync-change', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('active', function () {
                              vm.$emit('pouchdb-sync-active', {
                                  db: localDB,
                                  active: true,
                              });
                          })
                          .on('denied', function (err) {
                              vm.$emit('pouchdb-sync-denied', {
                                  db: localDB,
                                  error: err,
                              });
                          })
                          .on('complete', function (info) {
                              vm.$emit('pouchdb-sync-complete', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('error', function (err) {
                              vm.$emit('pouchdb-sync-error', {
                                  db: localDB,
                                  error: err,
                              });
                          });

                      return sync;
                  },
                  push: function push(localDB, remoteDB, options) {
                      if ( remoteDB === void 0 ) remoteDB=defaultDB;
                      if ( options === void 0 ) options = {};

                      if (!databases[localDB]) {
                          makeInstance(localDB);
                      }
                      if (!databases[remoteDB]) {
                          makeInstance(remoteDB);
                      }
                      if (!defaultDB) {
                          defaultDB = remoteDB;
                      }

                      var _options = Object.assign(
                          {},
                          {
                              live: true,
                              retry: true,
                              back_off_function: function (delay) {
                                  if (delay === 0) {
                                      return 1000;
                                  }
                                  return delay * 3;
                              },
                          },
                          options
                      );

                      var rep = databases[localDB].replicate
                          .to(databases[remoteDB], options)
                          .on('paused', function (err) {
                              if (err) {
                                  vm.$emit('pouchdb-push-error', {
                                      db: localDB,
                                      error: err,
                                  });
                                  return;
                              }
                              else {
                                  vm.$emit('pouchdb-push-paused', {
                                      db: localDB,
                                      paused: true,
                                  });
                              }
                          })
                          .on('change', function (info) {
                              vm.$emit('pouchdb-push-change', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('active', function () {
                              vm.$emit('pouchdb-push-active', {
                                  db: localDB,
                                  active: true,
                              });
                          })
                          .on('denied', function (err) {
                              vm.$emit('pouchdb-push-denied', {
                                  db: localDB,
                                  error: err,
                              });
                          })
                          .on('complete', function (info) {
                              vm.$emit('pouchdb-push-complete', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('error', function (err) {
                              vm.$emit('pouchdb-push-error', {
                                  db: localDB,
                                  error: err,
                              });
                          });

                      return rep;
                  },

                  pull: function pull(localDB, remoteDB, options) {
                      if ( remoteDB === void 0 ) remoteDB=defaultDB;
                      if ( options === void 0 ) options = {};

                      if (!databases[localDB]) {
                          makeInstance(localDB);
                      }
                      if (!databases[remoteDB]) {
                          makeInstance(remoteDB);
                      }
                      if (!defaultDB) {
                          defaultDB = remoteDB;
                      }

                      var _options = Object.assign(
                          {},
                          {
                              live: true,
                              retry: true,
                              back_off_function: function (delay) {
                                  if (delay === 0) {
                                      return 1000;
                                  }
                                  return delay * 3;
                              },
                          },
                          options
                      );

                      var rep = databases[localDB].replicate
                          .from(databases[remoteDB], options)
                          .on('paused', function (err) {
                              if (err) {
                                  vm.$emit('pouchdb-pull-error', {
                                      db: localDB,
                                      error: err,
                                  });
                                  return;
                              }
                              else {
                                  vm.$emit('pouchdb-pull-paused', {
                                      db: localDB,
                                      paused: true,
                                  });
                              }
                          })
                          .on('change', function (info) {
                              vm.$emit('pouchdb-pull-change', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('active', function () {
                              vm.$emit('pouchdb-pull-active', {
                                  db: localDB,
                                  active: true,
                              });
                          })
                          .on('denied', function (err) {
                              vm.$emit('pouchdb-pull-denied', {
                                  db: localDB,
                                  error: err,
                              });
                          })
                          .on('complete', function (info) {
                              vm.$emit('pouchdb-pull-complete', {
                                  db: localDB,
                                  info: info,
                              });
                          })
                          .on('error', function (err) {
                              vm.$emit('pouchdb-pull-error', {
                                  db: localDB,
                                  error: err,
                              });
                          });

                      return rep;
                  },

                  changes: function changes(options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      var _options = Object.assign(
                          {},
                          {
                              live: true,
                              retry: true,
                              back_off_function: function (delay) {
                                  if (delay === 0) {
                                      return 1000;
                                  }
                                  return delay * 3;
                              },
                          },
                          options
                      );

                      var changes = databases[db]
                          .changes(_options)
                          .on('change', function (info) {
                              vm.$emit('pouchdb-changes-change', {
                                  db: db,
                                  info: info,
                              });
                          })
                          .on('complete', function (info) {
                              vm.$emit('pouchdb-changes-complete', {
                                  db: db,
                                  info: info,
                              });
                          })
                          .on('error', function (err) {
                              vm.$emit('pouchdb-changes-error', {
                                  db: db,
                                  error: err,
                              });
                          });

                      return changes;
                  },

                  get: function get(object, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db].get(object, options);
                  },

                  put: function put(object, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db].put(object, options);
                  },

                  post: function post(object, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db].post(object, options);
                  },

                  remove: function remove(object, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db].remove(object, options);
                  },

                  query: function query(fun, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }
                      return databases[db].query(fun, options);
                  },

                  find: function find(options, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].find(options);
                  },

                  createIndex: function createIndex(index, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].createIndex(index);
                  },

                  allDocs: function allDocs(options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      var _options = Object.assign(
                          {},
                          { include_docs: true },
                          options
                      );

                      return databases[db].allDocs(_options);
                  },

                  bulkDocs: function bulkDocs(docs, options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].bulkDocs(docs, options);
                  },

                  compact: function compact(options, db) {
                      if ( options === void 0 ) options = {};
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].compact(options);
                  },

                  viewCleanup: function viewCleanup(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].viewCleanup();
                  },

                  info: function info(db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].info();
                  },

                  putAttachment: function putAttachment(docId, rev, attachment, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].putAttachment(
                          docId,
                          attachment.id,
                          rev ? rev : null,
                          attachment.data,
                          attachment.type
                      );
                  },

                  getAttachment: function getAttachment(docId, attachmentId, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].getAttachment(docId, attachmentId);
                  },

                  deleteAttachment: function deleteAttachment(docId, attachmentId, docRev, db) {
                      if ( db === void 0 ) db=defaultDB;

                      if (!databases[db]) {
                          makeInstance(db);
                      }

                      return databases[db].removeAttachment(
                          docId,
                          attachmentId,
                          docRev
                      );
                  },
              };

              // add non reactive api
              vm.$pouch = $pouch;
              //add non reactive property
              vm.$databases = databases; // Add non-reactive property

              var pouchOptions = this.$options.pouch;

              if (!pouchOptions) {
                  return;
              }

              if (typeof pouchOptions === 'function') {
                  pouchOptions = pouchOptions();
              }

              Object.keys(pouchOptions).map(function (key) {
                  var pouchFn = pouchOptions[key];
                  if (typeof pouchFn !== 'function') {
                      pouchFn = function () {
                          return pouchOptions[key];
                      };
                  }

                  // if the selector changes, modify the liveFeed object
                  //
                  vm.$watch(
                      pouchFn,
                      function (config) {
                          // if the selector is now giving a value of null or undefined, then return
                          // the previous liveFeed object will remain
                          if (!config) {
                              vm.$emit('pouchdb-livefeed-error', {
                                  db: key,
                                  config: config,
                                  error: 'Null or undefined selector',
                              });

                              return;
                          }


                          var selector, sort, skip, limit, first;

                          if (config.selector) {
                              selector = config.selector;
                              sort = config.sort;
                              skip = config.skip;
                              limit = config.limit;
                              first = config.first;
                          } else {
                              selector = config;
                          }

                          // the database could change in the config options
                          // so the key could point to a database of a different name
                          var databaseParam = config.database || key;
                          var db = null;

                          if (typeof databaseParam === 'object') {
                              db = databaseParam;
                          } else if (typeof databaseParam === 'string') {
                              if (!databases[databaseParam]) {
                                  makeInstance(databaseParam);
                              }
                              db = databases[databaseParam];
                          }
                          if (!db) {
                              vm.$emit('pouchdb-livefeed-error', {
                                  db: key,
                                  error: 'Null or undefined database',
                              });
                              return;
                          }
                          if (vm._liveFeeds[key]) {
                              vm._liveFeeds[key].cancel();
                          }
                          var aggregateCache = [];

                          // the LiveFind plugin returns a liveFeed object
                          vm._liveFeeds[key] = db
                              .liveFind({
                                  selector: selector,
                                  sort: sort,
                                  skip: skip,
                                  limit: limit,
                                  aggregate: true,
                              })
                              .on('update', function (update, aggregate) {
                                  if (first && aggregate)
                                      { aggregate = aggregate[0]; }

                                  vm.$data[key] = aggregateCache = aggregate;

                                  vm.$emit('pouchdb-livefeed-update', {
                                      db: key,
                                      name: db.name,
                                  });

                              })
                              .on('ready', function () {
                                  vm.$data[key] = aggregateCache;

                                  vm.$emit('pouchdb-livefeed-ready', {
                                      db: key,
                                      name: db.name,
                                  });
                              })
                              .on('cancelled', function() {
                                  vm.$emit('pouchdb-livefeed-cancel', {
                                      db: key,
                                      name: db.name,
                                  });
                              })
                              .on('error', function(err) {
                                  vm.$emit('pouchdb-livefeed-error', {
                                      db: key,
                                      name: db.name,
                                      error: err,
                                  });
                              });
                      },
                      {
                          immediate: true,
                      }
                  );
              });
          },
          // tear down the liveFeed objects
          beforeDestroy: function beforeDestroy() {
              var this$1 = this;

              Object.keys(this._liveFeeds).map(function (lfKey) {
                  this$1._liveFeeds[lfKey].cancel();
              });
          },
      };

      var api = {
          install: function (Vue, options) {
              var assign;

              if ( options === void 0 ) options = {};
              vue = Vue;

              ((assign = options, pouch = assign.pouch, pouch = pouch === void 0 ? PouchDB : pouch, defaultDB = assign.defaultDB, defaultDB = defaultDB === void 0 ? '' : defaultDB, optionsDB = assign.optionsDB, optionsDB = optionsDB === void 0 ? {} : optionsDB));

              // In PouchDB v7.0.0 the debug() API was moved to a separate plugin.
              // var pouchdbDebug = require('pouchdb-debug');
              // PouchDB.plugin(pouchdbDebug);
              if (options.debug === '*') { pouch.debug.enable('*'); }

              Vue.mixin(vuePouch);
          },
      };

      module.exports = api;
  })();

}));
